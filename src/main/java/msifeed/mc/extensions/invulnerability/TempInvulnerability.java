package msifeed.mc.extensions.invulnerability;

import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.eventhandler.EventPriority;
import cpw.mods.fml.common.eventhandler.SubscribeEvent;
import cpw.mods.fml.common.gameevent.PlayerEvent;
import cpw.mods.fml.common.gameevent.TickEvent;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.ChunkCoordinates;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.event.entity.player.AttackEntityEvent;

import java.util.HashMap;

public class TempInvulnerability {
    private static final int INV_DIST = 5;
    private final HashMap<Integer, ChunkCoordinates> players = new HashMap<>();

    public void init() {
        MinecraftForge.EVENT_BUS.register(this);
        FMLCommonHandler.instance().bus().register(this);
    }

    @SubscribeEvent
    public void onPlayerJoinWorld(EntityJoinWorldEvent event) {
        if (!event.entity.worldObj.isRemote && event.entity instanceof EntityPlayer)
            players.put(event.entity.getEntityId(), ((EntityPlayer) event.entity).getPlayerCoordinates());
    }

    @SubscribeEvent
    public void onPlayerLeave(PlayerEvent.PlayerLoggedOutEvent event) {
        players.remove(event.player.getEntityId());
    }

    @SubscribeEvent
    public void onPlayerAttack(AttackEntityEvent event) {
        players.remove(event.entityPlayer.getEntityId());
    }

    @SubscribeEvent
    public void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (event.player.worldObj.isRemote) return;

        final ChunkCoordinates cords = players.get(event.player.getEntityId());
        if (cords == null) return;

        final float dist = cords.getDistanceSquaredToChunkCoordinates(event.player.getPlayerCoordinates());
        if (dist > INV_DIST)
            players.remove(event.player.getEntityId());
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onTarget(LivingAttackEvent event) {
        if (!(event.entity instanceof EntityPlayer)) return;
        if (players.containsKey(event.entity.getEntityId()))
            event.setCanceled(true);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onHurt(LivingHurtEvent event) {
        if (!(event.entity instanceof EntityPlayer)) return;
        if (players.containsKey(event.entity.getEntityId()))
            event.setCanceled(true);
    }
}
